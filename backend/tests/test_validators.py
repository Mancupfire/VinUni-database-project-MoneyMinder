"""
Property-based tests for input validators.
Tests email, username, and amount validation using Hypothesis.
"""
import pytest
from hypothesis import given, strategies as st, settings, assume
import re
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from security.validators import InputValidator


class TestEmailValidation:
    """
    Property 3: Email Validation Correctness
    For any string input to the email validator, the validator SHALL return true 
    if and only if the string matches the RFC 5322 email format pattern.
    Validates: Requirements 2.1
    """
    
    @settings(max_examples=100)
    @given(st.emails())
    def test_valid_emails_accepted(self, email):
        """
        Feature: security-improvements, Property 3: Email Validation Correctness
        Valid emails generated by Hypothesis should be accepted.
        """
        # Hypothesis generates RFC-compliant emails
        # Our simplified regex may not accept all RFC-compliant emails,
        # but should accept common formats
        # Filter to emails our regex can handle
        if re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            assert InputValidator.validate_email(email) == True
    
    @settings(max_examples=100)
    @given(st.text(min_size=0, max_size=50))
    def test_invalid_emails_rejected(self, text):
        """
        Feature: security-improvements, Property 3: Email Validation Correctness
        Random text without @ symbol should be rejected.
        """
        assume('@' not in text or '.' not in text.split('@')[-1] if '@' in text else True)
        # Text without proper email structure should be rejected
        if '@' not in text:
            assert InputValidator.validate_email(text) == False
    
    @settings(max_examples=100)
    @given(st.sampled_from([
        'test@example.com',
        'user.name@domain.org',
        'user+tag@example.co.uk',
        'a@b.cd',
        'test123@test123.com',
    ]))
    def test_common_valid_emails(self, email):
        """Common valid email formats should be accepted."""
        assert InputValidator.validate_email(email) == True
    
    @settings(max_examples=100)
    @given(st.sampled_from([
        '',
        'notanemail',
        '@nodomain.com',
        'noat.com',
        'spaces in@email.com',
        'missing@tld',
        None,
    ]))
    def test_common_invalid_emails(self, email):
        """Common invalid email formats should be rejected."""
        assert InputValidator.validate_email(email) == False


class TestUsernameValidation:
    """
    Property 4: Username Validation Correctness
    For any string input to the username validator, the validator SHALL return true 
    if and only if the string contains only alphanumeric characters and underscores, 
    and has length between 3 and 50 characters inclusive.
    Validates: Requirements 2.2
    """
    
    @settings(max_examples=100)
    @given(st.from_regex(r'^[a-zA-Z0-9_]{3,50}$', fullmatch=True))
    def test_valid_usernames_accepted(self, username):
        """
        Feature: security-improvements, Property 4: Username Validation Correctness
        Usernames matching the pattern should be accepted.
        """
        assert InputValidator.validate_username(username) == True
    
    @settings(max_examples=100)
    @given(st.text(min_size=0, max_size=2))
    def test_short_usernames_rejected(self, username):
        """
        Feature: security-improvements, Property 4: Username Validation Correctness
        Usernames shorter than 3 characters should be rejected.
        """
        assert InputValidator.validate_username(username) == False
    
    @settings(max_examples=100)
    @given(st.text(min_size=51, max_size=100, alphabet=st.characters(whitelist_categories=('L', 'N'))))
    def test_long_usernames_rejected(self, username):
        """
        Feature: security-improvements, Property 4: Username Validation Correctness
        Usernames longer than 50 characters should be rejected.
        """
        assert InputValidator.validate_username(username) == False
    
    @settings(max_examples=100)
    @given(st.text(min_size=3, max_size=50))
    def test_special_chars_rejected(self, text):
        """
        Feature: security-improvements, Property 4: Username Validation Correctness
        Usernames with special characters (except underscore) should be rejected.
        """
        # If text contains characters other than alphanumeric and underscore
        if not re.match(r'^[a-zA-Z0-9_]+$', text):
            assert InputValidator.validate_username(text) == False


class TestAmountValidation:
    """
    Property 5: Amount Validation Correctness
    For any numeric input to the amount validator, the validator SHALL return true 
    if and only if the value is positive and has at most 2 decimal places.
    Validates: Requirements 2.4
    """
    
    @settings(max_examples=100)
    @given(st.decimals(min_value=0.01, max_value=1000000, places=2, allow_nan=False, allow_infinity=False))
    def test_valid_amounts_accepted(self, amount):
        """
        Feature: security-improvements, Property 5: Amount Validation Correctness
        Positive amounts with at most 2 decimal places should be accepted.
        """
        assert InputValidator.validate_amount(amount) == True
    
    @settings(max_examples=100)
    @given(st.floats(min_value=-1000000, max_value=0, allow_nan=False, allow_infinity=False))
    def test_negative_amounts_rejected(self, amount):
        """
        Feature: security-improvements, Property 5: Amount Validation Correctness
        Negative amounts should be rejected.
        """
        assert InputValidator.validate_amount(amount) == False
    
    @settings(max_examples=100)
    @given(st.decimals(min_value=0.001, max_value=1000, places=3, allow_nan=False, allow_infinity=False))
    def test_too_many_decimals_rejected(self, amount):
        """
        Feature: security-improvements, Property 5: Amount Validation Correctness
        Amounts with more than 2 decimal places should be rejected.
        """
        # Only test if actually has more than 2 decimal places
        str_amount = str(amount)
        if '.' in str_amount:
            decimal_places = len(str_amount.split('.')[1].rstrip('0'))
            if decimal_places > 2:
                assert InputValidator.validate_amount(amount) == False
    
    @settings(max_examples=100)
    @given(st.integers(min_value=1, max_value=1000000))
    def test_integer_amounts_accepted(self, amount):
        """
        Feature: security-improvements, Property 5: Amount Validation Correctness
        Positive integer amounts should be accepted.
        """
        assert InputValidator.validate_amount(amount) == True
    
    def test_zero_rejected(self):
        """Zero amount should be rejected."""
        assert InputValidator.validate_amount(0) == False
        assert InputValidator.validate_amount(0.0) == False
        assert InputValidator.validate_amount('0') == False


class TestStringLengthValidation:
    """Tests for string length validation."""
    
    @settings(max_examples=100)
    @given(st.text(min_size=0, max_size=50))
    def test_strings_within_limit_accepted(self, text):
        """Strings within the limit should be accepted."""
        assert InputValidator.validate_string_length(text, max_length=50) == True
    
    @settings(max_examples=100)
    @given(st.text(min_size=51, max_size=100))
    def test_strings_exceeding_limit_rejected(self, text):
        """Strings exceeding the limit should be rejected."""
        assert InputValidator.validate_string_length(text, max_length=50) == False
    
    def test_field_name_limits(self):
        """Test that field name limits are applied correctly."""
        # Username limit is 50
        assert InputValidator.validate_string_length('a' * 50, field_name='username') == True
        assert InputValidator.validate_string_length('a' * 51, field_name='username') == False
        
        # Email limit is 100
        assert InputValidator.validate_string_length('a' * 100, field_name='email') == True
        assert InputValidator.validate_string_length('a' * 101, field_name='email') == False


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
